<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Social Feed</title>
  <link rel="stylesheet" href="static/ggg.css" />

  <style>
    /* --- Post Header --- */
    .post-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
  
    .profile-pic {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: linear-gradient(135deg, #999, #555);
      flex-shrink: 0;
    }
  
    /* Wrap author info beside the profile picture */
    .post-header-info {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
  
    .post-author {
      font-weight: 600;
      color: var(--text-color);
      font-size: 1rem;
      margin-bottom: 2px;
    }
  
    .post-date {
      font-size: 0.8rem;
      opacity: 0.7;
    }
  
    /* --- Post Content --- */
    .post-content {
      font-size: 0.95rem;
      margin-top: 5px;
      line-height: 1.4;
    }
  
    /* --- Post Action Buttons (Like, Comment, View Reactors) --- */
    .post-actions {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin-top: 12px;
    }
  
    .post-actions button {
      flex: 1;
      padding: 8px 0;
      border: none;
      border-radius: 12px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.25s ease;
      background: rgba(255, 255, 255, 0.15);
      color: var(--text-color);
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
  
    .post-actions button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }
  
    .post-actions button:active {
      transform: scale(0.97);
    }
  
    /* --- Individual Button Themes --- */
    .like-btn {
      color: #ff6b6b;
    }
  
    .view-reactors-btn {
      color: #ffca3a;
    }
  
    .comment-btn {
      color: #4dabf7;
    }
  
    /* Add slight glow effect on hover */
    .like-btn:hover {
      box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
    }
    .view-reactors-btn:hover {
      box-shadow: 0 0 8px rgba(255, 202, 58, 0.6);
    }
    .comment-btn:hover {
      box-shadow: 0 0 8px rgba(77, 171, 247, 0.6);
    }
  
    /* --- Dark Mode Variant --- */
    [data-theme="dark"] .post-actions button {
      background: rgba(255, 255, 255, 0.08);
      color: #eaeaea;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
  
    [data-theme="dark"] .post-actions button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  
    [data-theme="dark"] .like-btn:hover {
      box-shadow: 0 0 8px rgba(255, 91, 91, 0.5);
    }
    [data-theme="dark"] .view-reactors-btn:hover {
      box-shadow: 0 0 8px rgba(255, 169, 77, 0.5);
    }
    [data-theme="dark"] .comment-btn:hover {
      box-shadow: 0 0 8px rgba(77, 184, 255, 0.5);
    }
  </style>
  
</head>
<body>
  <div class="container">
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="logo">MySocial</div>
      <nav>
        <button id="feedBtn">Feed</button>
        <button id="notificationsBtn">Notifications</button>
        <button id="activeUsersBtn">Active Users</button>
        <button id="logoutBtn">Logout</button>
      </nav>
      <button id="themeToggle" class="theme-btn">üåô</button>
    </aside>

    <!-- MAIN CONTENT -->
    <main class="main-content">
      <header class="topbar">
        <input type="text" id="searchInput" placeholder="Search..." />
      </header>

      <!-- CREATE POST -->
      <section class="create-post">
        <textarea id="postContent" placeholder="What's on your mind?"></textarea>
        <button id="postButton">Post</button>
      </section>

      <!-- FEED -->
      <section id="feed" class="feed">
        <!-- Posts will be dynamically loaded here -->
      </section>
    </main>

    <!-- EXTRA PANEL -->
    <aside class="extra-container" id="extra-container">
      <div class="notifications">
        <h3>Notifications</h3>
        <ul id="notificationsList"></ul>
      </div>

      <div class="active-users">
        <h3>Active Users</h3>
        <ul id="activeUsersList"></ul>
      </div>
    </aside>
  </div>

  <!-- COMMENT MODAL -->
  <div id="commentModal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="closeModal()">&times;</span>
      <h3>Comments</h3>
      <ul id="commentList"></ul>
      <textarea id="newComment" placeholder="Write a comment..."></textarea>
      <button id="addCommentBtn" onclick="addComment()">Add Comment</button>
    </div>
  </div>

  <!-- REACTORS MODAL -->
  <div id="reactorsModal" class="modal">
    <div class="modal-content">
      <span class="close-btn">&times;</span>
      <h3>Reactors</h3>
      <ul id="reactorsList"></ul>
    </div>
  </div>

  <script>
    // Theme toggle
    const toggle = document.getElementById("themeToggle");
    toggle.addEventListener("click", () => {
      const current = document.documentElement.getAttribute("data-theme");
      const newTheme = current === "light" ? "dark" : "light";
      document.documentElement.setAttribute("data-theme", newTheme);
      toggle.textContent = newTheme === "light" ? "üåô" : "‚òÄÔ∏è";
    });
  </script>
</body>
<script>
    window.addEventListener("DOMContentLoaded", async () => {
      if (!token) return;
      await markUserOnline();
      // Optional: refresh every 60s to keep presence alive
      window._presenceInterval = setInterval(markUserOnline, 60 * 1000);
    });
    // When the user closes or leaves the page
    window.addEventListener("beforeunload", async () => {
      try {
        await markUserOffline();
      } catch (err) {
        // ignore network errors ‚Äî page is closing
      }
      clearInterval(window._presenceInterval);
    });
    // API calls
    async function markUserOnline() {
      await fetch("https://animediabackend.onrender.com/users/online", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`
        }
      });
    }
    async function markUserOffline() {
      await fetch("https://animediabackend.onrender.com/users/online", {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${token}`
        }
      });
    }
    async function fetchActiveUsers() {
      try {
        const response = await fetch("https://animediabackend.onrender.com/users/active", {
          headers: {
            "Authorization": `Bearer ${token}`
          }
        });
        const data = await response.json();
        console.log("Active users API response:", data);
        const list = document.getElementById("activeUsersList");
        list.innerHTML = "";
        // Decode your own user ID
        const payload = JSON.parse(atob(token.split(".")[1]));
        const currentUserId = payload.sub;
        // Filter out yourself
        const filtered = data.filter(user => user.id !== currentUserId);
        if (filtered.length > 0) {
          filtered.forEach(user => {
            const div = document.createElement("div");
            div.className = "user-item";
            div.innerHTML = `
              <div class="online-dot"></div>
              <span>${user.username}</span>
              <button class="follow-btn" data-id="${user.id}">Follow</button>
            `;
            list.appendChild(div);
          });
          // Attach event listeners to all follow buttons
          document.querySelectorAll(".follow-btn").forEach(btn => {
            btn.addEventListener("click", async (e) => {
              const targetUserId = e.target.getAttribute("data-id");
              await followUser(targetUserId, e.target);
            });
          });
        } else {
          list.innerHTML = "<p>No other users online</p>";
        }
      } catch (error) {
        console.error("Error fetching active users:", error);
      }
    }
    async function followUser(targetUserId, buttonElement) {
      try {
        const response = await fetch("https://animediabackend.onrender.com/follows/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({ target_user_id: targetUserId })
        });
        if (!response.ok) {
          throw new Error("Failed to follow user");
        }
        const result = await response.json();
        console.log("Follow result:", result);
        // Update button UI
        buttonElement.textContent = "Following ‚úÖ";
        buttonElement.disabled = true;
        buttonElement.classList.add("following");
      } catch (error) {
        console.error("Error following user:", error);
      }
    }
    // Refresh the active users list every 10 seconds
    setInterval(fetchActiveUsers, 10000);
    fetchActiveUsers(); // load immediately on page load
        const frontendHost = window.location.hostname;
        const backendPort = 8000;
        const API_BASE_URL = `http://${frontendHost}:${backendPort}`;
        const token = localStorage.getItem("token");
        if (!token) {
          alert("You must log in first!");
          window.location.href = "index.html";
        }
        // Robust JWT parser (handles base64url)
        function parseJwt(t) {
          try {
            const base64Url = t.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
              return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
          } catch (e) {
            return null;
          }
        }
        function getCurrentUserId() {
          const payload = parseJwt(token);
          // Common claim names to check
          return payload?.sub || payload?.user_id || payload?.id || null;
        }
        async function fetchJson(url, opts = {}) {
          try {
            const res = await fetch(url, opts);
            if (!res.ok) return null;
            return await res.json();
          } catch (e) {
            console.warn("fetchJson error:", e);
            return null;
          }
        }  
        // ---- helper: normalize the react summary returned by backend ----
        async function fetchReactSummary(postId) {
          // endpoint may return either an object like { post_id, reacts, has_liked, like_count }
          // or (older) simply an array of reacts. This helper normalizes both shapes.
          const summary = await fetchJson(`https://animediabackend.onrender.com/reacts/post/${postId}`, {
            headers: { "Authorization": `Bearer ${token}` }
          });
          if (!summary) return { reacts: [], like_count: 0, has_liked: false };    
          if (Array.isArray(summary)) {
            // older shape: array of react objects
            return { reacts: summary, like_count: summary.length, has_liked: false };
          }    
          // assume object with fields; defensive defaults:
          return {
            reacts: Array.isArray(summary.reacts) ? summary.reacts : [],
            like_count: typeof summary.like_count === "number" ? summary.like_count : (Array.isArray(summary.reacts) ? summary.reacts.length : 0),
            has_liked: !!summary.has_liked
          };
        }
        // helper to fetch and normalize JSON result to array
        async function fetchJsonArray(url, opts = {}) {
          try {
            const res = await fetch(url, opts);
            if (!res.ok) return [];
            const data = await res.json();
            if (Array.isArray(data)) return data;
            if (data == null) return [];
            // if server returned a single object, wrap it in array
            if (typeof data === 'object') return [data];
            return [];
          } catch (e) {
            console.warn("fetchJsonArray error:", e);
            return [];
          }
        }
        async function addComment() {
          const content = document.getElementById("newComment").value.trim();
          if (!content || !currentPostId) return;
          try {
            const response = await fetch("https://animediabackend.onrender.com/comments/", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`
              },
              body: JSON.stringify({ post_id: currentPostId, content })
            });
            if (!response.ok) throw new Error("Failed to add comment");
            document.getElementById("newComment").value = "";
            commentPost(currentPostId);
          } catch (err) {
            console.error(err);
            alert("Error adding comment: " + err.message);
          }
        }
        async function createPost() {
          const content = document.getElementById("postContent").value.trim();
          if (!content) {
            alert("Post content cannot be empty!");
            return;
          }
          try {
            const response = await fetch("https://animediabackend.onrender.com/posts/", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`
              },
              body: JSON.stringify({ content })
            });
            if (!response.ok) throw new Error("Failed to create post");
            fetchPosts();
            document.getElementById("postContent").value = "";
          } catch (err) {
            console.error(err);
            alert("Error creating post: " + err.message);
          }
        }
        async function fetchPosts() {
          const feed = document.getElementById('feed');
          feed.innerHTML = '';
          try {
            const response = await fetch("https://animediabackend.onrender.com/posts/", {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`
              }
            });
            if (!response.ok) throw new Error(`Error: ${response.status}`);
            const posts = await response.json();
            if (!Array.isArray(posts) || posts.length === 0) {
              feed.innerHTML = "<p>No posts yet!</p>";
              return;
            }
            const currentUser = getCurrentUserId(); // should return user id string or null  
            for (const post of posts) {
              // parse created_at (your existing logic)
              const dateObj = post.created_at;
              const year = dateObj._DateTime__date._Date__year;
              const month = dateObj._DateTime__date._Date__month - 1;
              const day = dateObj._DateTime__date._Date__day;
              const hour = dateObj._DateTime__time._Time__hour;
              const minute = dateObj._DateTime__time._Time__minute;
              const second = dateObj._DateTime__time._Time__second;
              const createdAt = new Date(year, month, day, hour, minute, second);
              // fetch react summary
              const summary = await fetchReactSummary(post.id);
              // If backend provides has_liked, prefer it; otherwise check reacts array for current user id
              const reactsCount = summary.like_count ?? (summary.reacts ? summary.reacts.length : 0);
              const userReacted = (typeof summary.has_liked === 'boolean')
                ? summary.has_liked
                : (currentUser ? summary.reacts.some(r => r.user_id === currentUser) : false);
              const postElement = document.createElement('div');
              postElement.classList.add('post');
              postElement.innerHTML = `
              <div class="post-header">
                <div class="profile-pic"></div>
                <div class="post-header-info">
                  <div class="post-author">${post.author_username}</div>
                  <div class="post-date">${createdAt.toLocaleString()}</div>
                </div>
              </div>
              <div class="post-content">${post.content}</div>
              <div class="post-actions">
                <button 
                  id="like-btn-${post.id}" 
                  class="like-btn" 
                  style="color:${userReacted ? 'red' : ''}">
                  ${userReacted ? '‚ù§Ô∏è Liked' : 'ü§ç Like'}
                </button>
                <button 
                  class="view-reactors-btn" 
                  onclick="openReactors('${post.id}')">
                  üëç <span id="react-count-${post.id}">${reactsCount}</span>
                </button>
                <button 
                  class="comment-btn" 
                  onclick="commentPost('${post.id}')">
                  üí¨ Comment
                </button>
              </div>
            `;
            

              feed.appendChild(postElement);
              // attach like toggle handler
              const likeBtn = document.getElementById(`like-btn-${post.id}`);
              likeBtn.addEventListener('click', () => toggleLike(post.id, likeBtn));
            }
          } catch (err) {
            console.error(err);
            alert("Failed to fetch posts: " + err.message);
          }
        }
    async function toggleLike(postId, btn) {
      try {
        const currentUser = getCurrentUserId();
        if (!currentUser) { 
          alert("Can't determine current user"); 
          return; 
        }
        const summary = await fetchReactSummary(postId);
        const userReacted = summary.has_liked === true;
        const countEl = document.getElementById(`react-count-${postId}`);
        let currentCount = parseInt(countEl?.textContent || "0", 10);
        if (userReacted) {
          // user already liked ‚Üí send unlike
          const res = await fetch(`${API_BASE_URL}/reacts/unlike`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            },
            body: JSON.stringify({ target_id: postId, react_type: "like" }) // ‚úÖ add react_type
          });  
          if (!res.ok) throw new Error("Failed to unlike");
          btn.innerText = "Like";
          btn.style.color = "black";
          countEl.textContent = Math.max(0, currentCount - 1);
        }
        else {
          // user not liked yet ‚Üí send like
          const res = await fetch("https://animediabackend.onrender.com/reacts/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            },
            body: JSON.stringify({ target_id: postId, react_type: "like" })
          });
          if (!res.ok) throw new Error("Failed to like");
          btn.innerText = "Liked";
          btn.style.color = "red";
          countEl.textContent = currentCount + 1;
        }
      } catch (err) {
        console.error(err);
        alert("Error toggling like: " + err.message);
      }
    }
        let currentPostId = null; 
        async function commentPost(postId) {
          currentPostId = postId;
          const commentList = document.getElementById("commentList");
          commentList.innerHTML = "";
          try {
            const response = await fetch(`https://animediabackend.onrender.com/comments/post/${postId}`, {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`
              }
            });
            if (!response.ok) throw new Error("Failed to fetch comments");
            const comments = await response.json();
            if (comments.length === 0) {
              commentList.innerHTML = "<p>No comments yet!</p>";
            } else {
              comments.forEach(c => {
                const div = document.createElement("div");
                div.classList.add("comment");
                div.innerHTML = `
                  <div class="profile-pic"></div>
                  <div>
                    <div class="comment-author">${c.author_username}</div>
                    <div class="comment-text">${c.content}</div>
                  </div>
                `;
                commentList.appendChild(div);
              });
            }
            document.getElementById("commentModal").style.display = "flex";
          } catch (err) {
            console.error(err);
            alert("Error loading comments: " + err.message);
          }
        } 
        function closeModal() {
          const modal = document.getElementById("commentModal");
          modal.style.display = "none";
          document.getElementById("commentList").innerHTML = "";
          document.getElementById("newComment").value = "";
        }
    async function openReactors(postId) {
      try {
        const summary = await fetchReactSummary(postId);
        const users = summary.reacts || [];
        const modal = document.createElement("div");
        modal.classList.add("modal");
        modal.style.display = "flex";
        modal.innerHTML = `
          <div class="modal-content" style="width:350px;height:400px;overflow-y:auto;position:relative;">
            <div class="modal-header">
              Reacted Users
              <span class="close" style="cursor:pointer;font-weight:bold;" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div id="reactorList" style="padding:10px;"></div>
          </div>
        `;
        document.body.appendChild(modal);
        const reactorList = modal.querySelector("#reactorList");
        if (!Array.isArray(users) || users.length === 0) {
          reactorList.innerHTML = "<p>No reactions yet!</p>";
        } else {
          users.forEach(u => {
            const div = document.createElement("div");
            div.style.display = "flex";
            div.style.alignItems = "center";
            div.style.gap = "10px";
            div.style.marginBottom = "10px";
            div.innerHTML = `
              <div style="width:30px;height:30px;border-radius:50%;background:gray;"></div>
              <span>${u.user_username}</span>
            `;
            reactorList.appendChild(div);
          });
        }
      } catch (err) {
        console.error(err);
        alert("Failed to load reactors: " + err.message);
      }
    }
        // initial load
        fetchPosts();
      ;
      async function loadNotifications() {
        try {
          const token = localStorage.getItem("token"); // assuming you stored it at login
          if (!token) {
            console.warn("No token found. Please log in first.");
            return;
          }
          const response = await fetch("https://animediabackend.onrender.com/notifications/", {
            headers: {
              "Authorization": `Bearer ${token}`
            }
          });
          if (response.status === 403) {
            throw new Error("Access forbidden ‚Äî invalid or missing token.");
          }
          if (!response.ok) {
            throw new Error("Failed to fetch notifications.");
          }
          const notifications = await response.json();
          const extraContainer = document.querySelector(".extra-container");
          extraContainer.innerHTML = "<h2>Notifications</h2>"; 
          if (notifications.length === 0) {
            extraContainer.innerHTML += "<p>No notifications yet.</p>";
            return;
          }
          notifications.forEach(notif => {
            const notifDiv = document.createElement("div");
            notifDiv.classList.add("notification-item");
            notifDiv.style.padding = "10px";
            notifDiv.style.borderBottom = "1px solid #ccc"; 
            notifDiv.innerHTML = `
              <p><strong>${notif.sender_username}</strong>: ${notif.message}</p>
              <small>${new Date(notif.created_at).toLocaleString()}</small>
            `;
            extraContainer.appendChild(notifDiv);
          });
        } catch (error) {
          console.error("Error loading notifications:", error);
        }
      } 
      window.addEventListener("DOMContentLoaded", loadNotifications);
</script>
</html>
